# Synchronized和Lock区别

|                       | Synchronized                                                 | Lock                                                         |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 原始构成              | 是关键字，属于JVM层面。（monitorenter，monitorexit）         | Lock是具体类，是api层面                                      |
| 使用方法              | 不需要用户去手动释放锁，当代码执行完后系统会自动让线程释放对锁的占用 | 需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁现象 |
| 是否可中断            | 不可中断，除非抛出异常或者正常运行完成                       | 可中断，1、设置超时方法tryLock(long timeout, timeUnit unit)，2、lockInterruptibly()放代码块中，调用interrupt()方法可中断。 |
| 加锁是否公平          | 非公平锁                                                     | 两者都可以，默认非公平锁，构造方法可以传入boolean值，true为公平锁，false为非公平锁。 |
| 绑定多个条件Condition | 没有                                                         | 用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像synchronized要么随机唤醒一个，要么全部唤醒 |

## Condition

